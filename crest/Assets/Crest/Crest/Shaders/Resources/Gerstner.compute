// Crest Ocean System

// This file is subject to the MIT License as seen in the root of this folder structure (LICENSE)

#pragma kernel Gerstner

#include "HLSLSupport.cginc"

#include "../OceanGlobals.hlsl"
#include "../OceanInputsDriven.hlsl"
#include "../OceanHelpersNew.hlsl"

float _TextureRes;
uint _FirstCascadeIndex;

struct GerstnerCascadeParams
{
	int _startIndex;
};
StructuredBuffer<GerstnerCascadeParams> _GerstnerCascadeParams;

struct GerstnerWaveComponent4
{
	float4 _twoPiOverWavelengths;
	float4 _amps;
	float4 _waveDirX;
	float4 _waveDirZ;
	float4 _phases;
	float4 _chopAmps;
};
StructuredBuffer<GerstnerWaveComponent4> _GerstnerWaveData;

RWTexture2DArray<half4> _WaveBuffer;

// 7.7us

void ComputeGerstner( float2 worldPosXZ, float worldSize, GerstnerWaveComponent4 data, inout float3 result, inout float2 displacementNormalized )
{
	// direction
	half4 Dx = data._waveDirX;
	half4 Dz = data._waveDirZ;

	// wave number
	half4 k = data._twoPiOverWavelengths;

	half4 kx = k * Dx;
	half4 kz = k * Dz;
	// http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.161.9102&rep=rep1&type=pdf eqn 19
	// kx = 2 pi n / L
	// kx / (2pi/L) = n
	float4 n = kx / (2.0 * 3.141592654 / worldSize);
	float4 m = kz / (2.0 * 3.141592654 / worldSize);
	n = round( n );
	m = round( m );
#if 1
	kx = 2.0 * 3.141592654 * n / worldSize;
	kz = 2.0 * 3.141592654 * m / worldSize;
#endif

	// spatial location
	float4 x = kx * worldPosXZ.x + kz * worldPosXZ.y;
	half4 angle = x + data._phases;

	// dx and dz could be baked into _ChopAmps
	half4 disp = data._chopAmps * sin( angle );
	half4 resultx = disp * Dx;
	half4 resultz = disp * Dz;

	half4 resulty = data._amps * cos( angle );

	// sum the vector results
	result.x += dot( resultx, 1.0 );
	result.y += dot( resulty, 1.0 );
	result.z += dot( resultz, 1.0 );

	half4 sssFactor = min( 1.0, data._twoPiOverWavelengths );
	displacementNormalized.x += dot( resultx, sssFactor );
	displacementNormalized.y += dot( resultz, sssFactor );
}

[numthreads(THREAD_GROUP_SIZE_X, THREAD_GROUP_SIZE_Y, 1)]
void Gerstner(uint3 id : SV_DispatchThreadID)
{
	const uint cascadeIndex = id.z + _FirstCascadeIndex;
	const float worldSize = (float)(1 << cascadeIndex);

	// Each cascade lies on XZ plane and starts from the origin
	const float texelWidth = worldSize / _TextureRes;
	const float2 worldPosXZ = (id.xy + 0.5) * texelWidth;

	float3 result = 0.0;
	float2 displacementNormalized = 0.0;

	const int startIndex = _GerstnerCascadeParams[cascadeIndex]._startIndex;
	const int endIndex = _GerstnerCascadeParams[cascadeIndex + 1]._startIndex;
	for( int i = startIndex; i < endIndex; i++ )
	{
		// Sum up waves from another buffer
		ComputeGerstner( worldPosXZ, worldSize, _GerstnerWaveData[i], result, displacementNormalized );
	}

	half sss = length( displacementNormalized );

	_WaveBuffer[uint3(id.xy, cascadeIndex)] = float4(result, sss);
}
